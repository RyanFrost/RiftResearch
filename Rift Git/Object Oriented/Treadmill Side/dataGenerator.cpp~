#include "dataGenerator.h"


#include <ctime>
#include <cstdlib>
#include <string>
#include <iostream>
#include <math.h>
#include <vector>
#include <algorithm>

#include <boost/lexical_cast.hpp>
#include <boost/thread.hpp>
#include <chrono>





dataGenerator::dataGenerator(int numberPatches) : numPatches(numberPatches)
{
	patchGenerator();
	patchTypeGenerator();
	patchSeparationGenerator();
}


dataGenerator::~dataGenerator()
{
}




void dataGenerator::patchGenerator(void)
{
	
	patches.clear(); // Clears patch vector for reuse
	
	srand(std::time(0));
	int patchStart = 20;
	patchStart -= 500;
	
	int pLocation = patchStart;



	for (int i = 0; i<numPatches; i++)
	{
		int separation = std::rand() % 3 + 5;
		pLocation += separation;
		patches.push_back(pLocation);
	}
}



void dataGenerator::patchTypeGenerator(void)
{
	
	int numPert = 10;
	std::vector<int> patchTypeOrder;
	patchTypeOrder.insert(patchTypeOrder.end(), numPert / 2, 2);
	patchTypeOrder.insert(patchTypeOrder.end(), numPert / 2, 3);

	std::random_shuffle(patchTypeOrder.begin(), patchTypeOrder.end());

	patchTypes.insert(patchTypes.begin(), numPatches, 1);

	int currentPatch = 0;
	int startingBuffer = 20; // Number of patches before the first perturbation
	int avgPatchesBetween = 10;
	currentPatch += startingBuffer;

	

	for (std::vector<int>::const_iterator iter = patchTypeOrder.begin(); iter != patchTypeOrder.end(); iter++)
	{
		patchTypes[currentPatch] = *iter;
		currentPatch += avgPatchesBetween - 2 + std::rand() % 5;
	}

}


void dataGenerator::patchSeparationGenerator(void)
{
	patchSeparations[0] = 0;
	for(int i = 1; i < patches.size(); i++)
	{
		patchSeparations[i] = (double) (patches[i] - patches[i-1]) /2;
	}
}


void dataGenerator::angleFootPosGenerator(void)
{

	typedef std::chrono::high_resolution_clock Clock;
	typedef std::chrono::duration<double> secDouble;
	
	std::chrono::high_resolution_clock timer;
	
	Clock::time_point startTime = timer.now();
	secDouble secs;

	angles.resize(6);
	

	int runLoop = 1;
	while (runLoop)
	{
		secs = timer.now() - startTime;
		
		footPos = 45 * sin(secs.count()) + 50;
		
		angles[0] = 20 * sin(secs.count()) + 20;		// Toe angle
		angles[1] = 40 * sin(secs.count() - 1) + 40;	// Knee angle
		angles[2] = 30 * sin(secs.count() + 0.5) -10 ;	// Hip angle
		
		angles[3] = 20 * sin(secs.count() + 3.14) + 20;		// Toe angle
		angles[4] = 40 * sin(secs.count() - 1 + 3.14) + 40;	// Knee angle
		angles[5] = 30 * sin(secs.count() + 0.5 + 3.14) - 10 ;	// Hip angle
		
	}

}


// Starts the angle generation in a separate thread

void dataGenerator::startAngleGen(void)
{
	boost::thread t1(&dataGenerator::angleFootPosGenerator, this);
}




std::vector<int> dataGenerator::getPatches(void)
{
	return patches;
}

std::vector<int> dataGenerator::getPatchTypes(void)
{
	return patchTypes;
}

std::vector<double> dataGenerator::getAngles(void)
{
	return angles;
}

double dataGenerator::getFootPos(void)
{
	return footPos;
}